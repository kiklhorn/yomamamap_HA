#Dirty code
#ToDo:
  # change http update intervals to millis in lambdas 
  # look at:
        # - addressable_lambda:
        #   name: "VOLBY @jirka1213 New Wheel"
  # Add some kind of inputs to vote parameters
  # Hardcoded at the end of this code now



esphome:
  name: rgbcrmap
  includes:
    - wheel.h
    # - tinyxml2.h
    # - tinyxml2.cpp
    - okres.h
    # - <esp_task_wdt.h>
    # esp_task_wdt_init(15 /* timeout */, false /* panic */);
    # - libs/xml2json/rapidxml
    # - libs/xml2json/rapidjson
    # - libs/xml2json/xml2json.hpp

  on_boot: 
    priority: -100
    then:
      - delay: 5s
      - script.execute: getTemperaturesData
      - script.execute: getVoteData


esp32:
  board: esp32doit-devkit-v1
  framework: 
    type: arduino

# Enable logging
logger:

web_server:
  # js_include: "./v2/www.js"
  # js_url: ""
  # version: 2
  
# custom_component:
#     - lambda: |-
#         auto my_custom = new EggCooker(id(secs),id(state));
#         App.register_component(my_custom);
#         return {my_custom};

# Enable Home Assistant API
api:
  encryption:
    key: "ZXINxDk5Sk8o4+dS6XveJ2qurVltdoWJKurU/mVevns="

ota:
  password: "b93d1d0149cede226333702f570533e5"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: True

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Rgbcrmap Fallback Hotspot"
  #   password: "BfPrNYK8vZ83"

captive_portal:

switch:
  - platform: restart
    name: "Restart rgbcrmap"
  - platform: safe_mode
    name: "Restart (Safe Mode) rgbcrmap"

globals:
  - id: tempData
    type: String
    restore_value: False
    initial_value: '"{}"'
  - id: voteData
    type: String
    restore_value: False
    initial_value: '"{}"'

light:
  - platform: neopixelbus
    # restore_mode: ALWAYS_OFF
    type: GRB
    variant: WS2812
    pin: GPIO13
    # method: 
    num_leds: 77
    name: "NeoPixel Light"
    id: neo
    default_transition_length: 
      seconds: 0

  # - platform: fastled_clockless
    # chipset: WS2812B
    # pin: GPIO13
    # # method: 
    # num_leds: 77
    # rgb_order: GRB
    # name: "NeoPixel Light"
    # id: neo
    # default_transition_length: 
    #   seconds: 0
    effects:
      - addressable_color_wipe:
      - addressable_color_wipe:
          name: Color Wipe Effect With Custom Values
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 1
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: false
      - addressable_lambda:
          name: "Mapa teplot TMEP @tvoje___mama Adafruit Wheel"
          update_interval: 5s
          lambda: |-
            //id(getTemperaturesData).execute();
            DynamicJsonDocument doc(6144);
            Serial.println(id(tempData));
            DeserializationError error = deserializeJson(doc, id(tempData));
            if (error) {
              Serial.print("deserializeJson() failed: ");
              Serial.println(error.c_str());
              return;
            }
            for (JsonObject item : doc.as<JsonArray>()) {
              int ledIndex = item["id"]; // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, ...
              ledIndex -= 1;
              float h = item["h"]; // -0.6, -4.3, -2.2, -1.5, -0.5, -0.5, 0.9, -0.4, -2.5, -0.5, -2.2, -3.4, -3.9, ...
              int color = map(h, -15, 40, 170, 0);
              //it[ledIndex] = Wheel(color);
              it[ledIndex] = WheelAda(color); //Adafruit values - podivej se do wheel.h, jsou tam odkazy
              serialPrintf("okres: %d, teplota: %.2f, barva rgb: (Wheel/WheelAda) %d/%d %d/%d %d/%d\n",ledIndex,h,Wheel(color)[0],WheelAda(color)[0],Wheel(color)[1],WheelAda(color)[1],Wheel(color)[2],WheelAda(color)[2]);
            }
            //id(neo).turn_on().set_brightness(0.99).perform();
      - addressable_lambda:
          name: "Mapa teplot TMEP @tvoje___mama New Wheel"
          update_interval: 5s
          lambda: |-
            //id(getTemperaturesData).execute();
            DynamicJsonDocument doc(6144);
            Serial.println(id(tempData));
            DeserializationError error = deserializeJson(doc, id(tempData));
            if (error) {
              Serial.print("deserializeJson() failed: ");
              Serial.println(error.c_str());
              return;
            }
            for (JsonObject item : doc.as<JsonArray>()) {
              int ledIndex = item["id"]; // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, ...
              ledIndex -= 1;
              float h = item["h"]; // -0.6, -4.3, -2.2, -1.5, -0.5, -0.5, 0.9, -0.4, -2.5, -0.5, -2.2, -3.4, -3.9, ...
              h = h*1.0;
              int color = map(h, -15, 40, 170, 0);
              it[ledIndex] = Wheel(color);
              //it[ledIndex] = WheelAda(color); //Adafruit values - podivej se do wheel.h, jsou tam odkazy
              serialPrintf("okres: %d, teplota: %.2f, barva rgb: (Wheel/WheelAda) %d/%d %d/%d %d/%d\n",ledIndex,h,Wheel(color)[0],WheelAda(color)[0],Wheel(color)[1],WheelAda(color)[1],Wheel(color)[2],WheelAda(color)[2]);
            }
            //id(neo).turn_on().set_brightness(0.99).perform();
      - addressable_lambda:
          name: "TMEP @jirka1213 AdafruitWheel"
          update_interval: 5s
          lambda: |-
            //id(getTemperaturesData).execute();
            double maxTemp = -99;
            double minTemp =  99;
            DynamicJsonDocument doc(4096);
            //DynamicJsonDocument doc(6144);
            Serial.println(id(tempData));
            DeserializationError error = deserializeJson(doc, id(tempData));
            if (error) {
              Serial.print("deserializeJson() failed: ");
              Serial.println(error.c_str());
              return;
            }
            //Zjisti min a max teplotu pro mapping
            for (JsonObject item : doc.as<JsonArray>()) {
              float h = item["h"];
              if (h < minTemp) minTemp = h;
              if (h > maxTemp) maxTemp = h;
            }

            for (JsonObject item : doc.as<JsonArray>()) {
              int ledIndex = item["id"]; // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, ...
              ledIndex -= 1;
              float h = item["h"]; // -0.6, -4.3, -2.2, -1.5, -0.5, -0.5, 0.9, -0.4, -2.5, -0.5, -2.2, -3.4, -3.9, ...
              int color = map(h, minTemp, maxTemp, 170, 0);
              //it[ledIndex] = Wheel(color);
              it[ledIndex] = WheelAda(color); //Adafruit values - podivej se do wheel.h, jsou tam odkazy
              serialPrintf("okres: %d, teplota: %f, barva rgb: (Wheel/WheelAda) %d/%d %d/%d %d/%d\n",ledIndex,h,Wheel(color)[0],WheelAda(color)[0],Wheel(color)[1],WheelAda(color)[1],Wheel(color)[2],WheelAda(color)[2]);
            }
            //id(neo).turn_on().set_brightness(0.99).perform();
      - addressable_lambda:
          name: "TMEP @jirka1213 New Wheel"
          update_interval: 5s
          lambda: |-
            //id(getTemperaturesData).execute();
            double maxTemp = -99;
            double minTemp =  99;
            DynamicJsonDocument doc(6144);
            Serial.println(id(tempData));
            DeserializationError error = deserializeJson(doc, id(tempData));
            if (error) {
              Serial.print("deserializeJson() failed: ");
              Serial.println(error.c_str());
              return;
            }
            //Zjisti min a max teplotu pro mapping
            for (JsonObject item : doc.as<JsonArray>()) {
              float h = item["h"];
              if (h < minTemp) minTemp = h;
              if (h > maxTemp) maxTemp = h;
            }

            for (JsonObject item : doc.as<JsonArray>()) {
              int ledIndex = item["id"]; // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, ...
              ledIndex -= 1;
              float h = item["h"]; // -0.6, -4.3, -2.2, -1.5, -0.5, -0.5, 0.9, -0.4, -2.5, -0.5, -2.2, -3.4, -3.9, ...
              int color = map(h, minTemp, maxTemp, 170, 0);
              it[ledIndex] = Wheel(color);
              //it[ledIndex] = WheelAda(color); //Adafruit values - podivej se do wheel.h, jsou tam odkazy
              serialPrintf("okres: %s, \t\tteplota: %.2f, barva rgb: (Wheel/WheelAda) %d/%d %d/%d %d/%d\n",(ledNames[ledIndex]).c_str(),h,Wheel(color)[0],WheelAda(color)[0],Wheel(color)[1],WheelAda(color)[1],Wheel(color)[2],WheelAda(color)[2]);
            }
            //id(neo).turn_on().set_brightness(0.99).perform();
      - addressable_lambda:
          name: "test kraju 1"
          update_interval: 10000ms
          lambda: |-         
            it.range(0,3) = Color::random_color(); //Karlovarsky
            it.range(3,10) = Color::random_color(); //Ustecky
            it.range(10,14) = Color::random_color(); //Liberecky
            it.range(14,19) = Color::random_color(); //KH
            it.range(19,23) = Color::random_color(); //Pardubicky
            it.range(23,32) = Color::random_color(); //Moravsloslezsky
            it.range(32,37) = Color::random_color(); //Zlinsky
            it.range(37,45) = Color::random_color(); //Jihomoravsky
            it.range(45,50) = Color::random_color(); //Vysocina
            Color olomouc = Color::random_color();
            it[23] = olomouc; //Olomoucky
            it[24] = olomouc;
            it[26] = olomouc;
            it[33] = olomouc;
            it[39] = olomouc;
            it.range(50,57) = Color::random_color();//Jihocesky
            it.range(57,64) = Color::random_color();//Plzensky
            it.range(64,76) = Color::random_color();//Stredocesky
            it[76] = Color::random_color(); //Praha
      - addressable_lambda:
          name: "test kraju 2"
          update_interval: 330ms
          lambda: |-    
            int nn = random(0,255), n[14];//from red to magenta? 255max 
            /*for (int element : n) {
              element = nn;
              nn += (220/14);
              //nn += (255/7);
              if (nn >= 220) { nn -= 220; }
              ESP_LOGD("custom", "e: %d -> %d", n, nn);
            }*/
              for (int i=0; i<14; i++) {
              n[i] = nn;
              nn += (255/15);
              //nn += (255/7);
              if (nn >= 255) { nn -= 255; }
              //ESP_LOGD("custom", "e: %d -> %d", i, n[i]);
            }  

            it.range(0,3) = Wheel(n[0]); //Karlovarsky
            it.range(3,10) = Wheel(n[1]); //Ustecky
            it.range(10,14) = Wheel(n[2]); //Liberecky
            it.range(14,19) = Wheel(n[3]); //KH
            it.range(19,23) = Wheel(n[4]); //Pardubicky
            it.range(23,32) = Wheel(n[5]); //Moravsloslezsky
            it.range(32,37) = Wheel(n[6]); //Zlinsky
            it.range(37,45) = Wheel(n[7]); //Jihomoravsky
            it.range(45,50) = Wheel(n[8]); //Vysocina
            Color olomouc = Wheel(n[9]);
            it[23] = olomouc; //Olomoucky
            it[24] = olomouc;
            it[26] = olomouc;
            it[33] = olomouc;
            it[39] = olomouc;
            it.range(50,57) = Wheel(n[10]);//Jihocesky
            it.range(57,64) = Wheel(n[11]);//Plzensky
            it.range(64,76) = Wheel(n[12]);//Stredocesky
            it[76] = Wheel(n[13]); //Praha

      # - addressable_lambda:
      #     name: "volby 1. kolo"
      #     update_interval: 65s
      #     lambda: |- 
      #       id(getVoteData1).execute();     
      #       Serial.println(id(vote1Data));   
      #       using namespace tinyxml2;
      #       XMLDocument xmlDocument;
      #       auto error = xmlDocument.Parse(id(vote1Data).c_str());
      #       Serial.println(xmlDocument.ErrorStr());
      #       if (error != XML_SUCCESS) {
      #         return;
      #       }
      #       it.range(0,3) = Color::random_color(); //Karlovarsky
      #       it.range(3,10) = Color::random_color(); //Ustecky
      #       it.range(10,14) = Color::random_color(); //Liberecky
      #       it.range(14,19) = Color::random_color(); //KH
      #       it.range(19,23) = Color::random_color(); //Pardubicky
      #       it.range(23,32) = Color::random_color(); //Moravsloslezsky
      #       it.range(32,37) = Color::random_color(); //Zlinsky
      #       it.range(37,45) = Color::random_color(); //Jihomoravsky
      #       it.range(45,50) = Color::random_color(); //Vysocina
      #       Color olomouc = Color::random_color();
      #       it[23] = olomouc; //Olomoucky
      #       it[24] = olomouc;
      #       it[26] = olomouc;
      #       it[33] = olomouc;
      #       it[39] = olomouc;
      #       it.range(50,57) = Color::random_color();//Jihocesky
      #       it.range(57,64) = Color::random_color();//Plzensky
      #       it.range(64,76) = Color::random_color();//Stredocesky
      #       it[76] = Color::random_color(); //Praha
      #       id(neo).turn_on().set_brightness(0.5).perform();
      - addressable_lambda:
          name: "5°C rozdíl na celou mapu New Wheel"
          update_interval: 50ms
          lambda: |-
            int range = 5; //kolik °c rozdílu na celou mapu
            int mint = -15; //minimální teplota, odpovídá modré barvě
            int maxt = 40; //maximální teplota, odpovídí červené barvě
            static float h = mint;
            static int direction = 1;
            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              it.all() = Color::BLACK;
              h= -15;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }
            // it.size() - Number of LEDs
            // it[num] - Access the LED at index num.
            // Set the LED at num to the given r, g, b values
            // it[num] = Color(r, g, b);
            // Get the color at index num (Color instance)
            // it[num].get();

            // Example: Simple color wipe
            for (int i = it.size() - 1; i > 0; i--) {
              it[i] = it[i - 1].get();
            }
            int color = map(h, mint, maxt, 170, 0); // -15 .. 40°C
            h += direction * range/float(it.size()); //
            //ESP_LOGD("custom", "h: %.2f ", h);
            if (h>=maxt & direction){
              direction = -1;
            }
            if (h<=mint & direction == -1){
              direction = 1;
            }
            it[0] = Wheel(color);

      - addressable_lambda:
          name: "5°C rozdíl na celou mapu Adafruit Wheel"
          update_interval: 50ms
          lambda: |-
            int range = 5; //kolik °c rozdílu na celou mapu
            int mint = -15; //minimální teplota, odpovídá modré barvě
            int maxt = 40; //maximální teplota, odpovídí červené barvě
            static float h = mint;
            static int direction = 1;
            // To reset static when stopping and starting the effect
            // again you can use the initial_run variables
            if (initial_run) {
              it.all() = Color::BLACK;
              h= -15;
              // optionally do a return so nothing happens until the next update_interval
              return;
            }
            // it.size() - Number of LEDs
            // it[num] - Access the LED at index num.
            // Set the LED at num to the given r, g, b values
            // it[num] = Color(r, g, b);
            // Get the color at index num (Color instance)
            // it[num].get();

            // Example: Simple color wipe
            for (int i = it.size() - 1; i > 0; i--) {
              it[i] = it[i - 1].get();
            }
            int color = map(h, mint, maxt, 170, 0); // -15 .. 40°C
            h += direction * range/float(it.size()); //
            //ESP_LOGD("custom", "h: %.2f ", h);
            if (h>=maxt & direction){
              direction = -1;
            }
            if (h<=mint & direction == -1){
              direction = 1;
            }
            it[0] = WheelAda(color);
      - addressable_lambda:
          name: "VOLBY @jirka1213 New Wheel"
          update_interval: 5s
          lambda: |-
            if (initial_run) {
              it.all() = Color::BLACK;
              id(getVoteData).execute(); //try prepare data on Node-RED (buffered mode, see comments on node-RED flow)
              // optionally do a return so nothing happens until the next update_interval
              // return;
            }
            static int last_update;
            int update_time = 50; //how quickly to update in seconds
            if((last_update + (update_time * 1000)) < millis()){
              last_update = millis();
              id(getVoteData).execute(); // (read previous data and prepare data for the next read(buffered mode))
            }
            double maxTemp = -99;
            double minTemp =  99;
            DynamicJsonDocument doc(6144); // size calculator: https://arduinojson.org/v6/assistant/
            Serial.println(id(voteData));
            DeserializationError error = deserializeJson(doc, id(voteData));
            if (error) {
              Serial.print("deserializeJson() failed: ");
              Serial.println(error.c_str());
              return;
            }
            //Zjisti min a max teplotu pro mapping
            for (JsonObject item : doc.as<JsonArray>()) {
              float h = item["h"];
              if (h < minTemp) minTemp = h;
              if (h > maxTemp) maxTemp = h;
            }

            for (JsonObject item : doc.as<JsonArray>()) {
              int ledIndex = item["id"]; // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, ...
              ledIndex -= 1;
              float h = item["h"]; // -0.6, -4.3, -2.2, -1.5, -0.5, -0.5, 0.9, -0.4, -2.5, -0.5, -2.2, -3.4, -3.9, ...
              int color = map(h, minTemp, maxTemp, 0, 170);
              if (h == -99) {  //nejsou k dispozici realna data, nastavim flag pro znovunacteni po skonceni cyklu, nebo zatim proste zobrazim mapu fialovou
           
                color = 218;
              }
              it[ledIndex] = Wheel(color);
              //it[ledIndex] = WheelAda(color); //Adafruit values - podivej se do wheel.h, jsou tam odkazy
              serialPrintf("okres: %s, \t\tteplota: %.2f, barva rgb: (Wheel/WheelAda) %d/%d %d/%d %d/%d\n",(ledNames[ledIndex]).c_str(),h,Wheel(color)[0],WheelAda(color)[0],Wheel(color)[1],WheelAda(color)[1],Wheel(color)[2],WheelAda(color)[2]);
            }


json:

http_request:
  id: http_request_data
  useragent: esphome/rgbcrmap
  timeout: 15s

async_tcp:

# https://arduinojson.org/v6/assistant/#/step1
time:
  - platform: sntp
    on_time:
      - seconds: 0
        minutes: /5
        then:
          - script.execute: getTemperaturesData

script:
  - id: getTemperaturesData
    mode: queued
    then:
      - logger.log:
          level: info
          format: "HTTP Request get Data"
      - http_request.get:
          url: "http://cdn.tmep.cz/app/export/okresy-cr-teplota.json"
          headers:
            Content-Type: application/json
          verify_ssl: false
          on_response:
            - if:
                condition:
                  lambda: |-
                    return status_code == 200;  
                then:
                  - logger.log:
                      level: info
                      tag: "getTemperaturedata"
                      format: "Response status: %d, Duration: %u ms"
                      args:
                        - status_code
                        - duration_ms  
                  - lambda: |- 
                      //String tempData;
                      id(tempData) = id(http_request_data).get_string();
  - id: getVoteData
    mode: queued
    then:
      - logger.log:
          level: info
          format: "HTTP Request get Data"
      - http_request.get:
          url: "https://192.168.199.99:1880/endpoint/volby?buff=true&typ=prezident&kolo=1&rok=2013"   #rok 2013,2018,2023...  URL params - look at Node-RED flow
          headers:
            Content-Type: application/json
          verify_ssl: false
          on_response:
            - if:
                condition:
                  lambda: |-
                    return status_code == 200;  
                then:
                  - logger.log:
                      level: info
                      tag: "getTemperaturedata"
                      format: "Response status: %d, Duration: %u ms"
                      args:
                        - status_code
                        - duration_ms  
                  - lambda: |- 
                      //String tempData;
                      id(voteData) = id(http_request_data).get_string();